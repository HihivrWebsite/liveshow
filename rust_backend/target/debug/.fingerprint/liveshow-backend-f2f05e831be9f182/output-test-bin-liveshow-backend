{"$message_type":"diagnostic","message":"unused import: `cors::CorsLayer`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src\\main.rs","byte_start":327,"byte_end":342,"line_start":15,"line_end":15,"column_start":5,"column_end":20,"is_primary":true,"text":[{"text":"    cors::CorsLayer,","highlight_start":5,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"remove the unused import","code":null,"level":"help","spans":[{"file_name":"src\\main.rs","byte_start":327,"byte_end":348,"line_start":15,"line_end":16,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    cors::CorsLayer,","highlight_start":5,"highlight_end":21},{"text":"    services::ServeDir,","highlight_start":1,"highlight_end":5}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unused import: `cors::CorsLayer`\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\main.rs:15:5\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m15\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     cors::CorsLayer,\n   \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[93m^^^^^^^^^^^^^^^\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n   \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0283","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0283\nlet x = \"hello\".chars().rev().collect();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nA common example is the `collect` method on `Iterator`. It has a generic type\nparameter with a `FromIterator` bound, which for a `char` iterator is\nimplemented by `Vec` and `String` among others. Consider the following snippet\nthat reverses the characters of a string:\n\nIn the first code example, the compiler cannot infer what the type of `x` should\nbe: `Vec<char>` and `String` are both suitable candidates. To specify which type\nto use, you can use a type annotation on `x`:\n\n```\nlet x: Vec<char> = \"hello\".chars().rev().collect();\n```\n\nIt is not necessary to annotate the full type. Once the ambiguity is resolved,\nthe compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nWe can see a self-contained example below:\n\n```compile_fail,E0283\nstruct Foo;\n\nimpl Into<u32> for Foo {\n    fn into(self) -> u32 { 1 }\n}\n\nlet foo = Foo;\nlet bar: u32 = foo.into() * 1u32;\n```\n\nThis error can be solved by adding type annotations that provide the missing\ninformation to the compiler. In this case, the solution is to specify the\ntrait's type parameter:\n\n```\nstruct Foo;\n\nimpl Into<u32> for Foo {\n    fn into(self) -> u32 { 1 }\n}\n\nlet foo = Foo;\nlet bar: u32 = Into::<u32>::into(foo) * 1u32;\n```\n"},"level":"error","spans":[{"file_name":"src\\middleware.rs","byte_start":966,"byte_end":968,"line_start":42,"line_end":42,"column_start":5,"column_end":7,"is_primary":true,"text":[{"text":"    Ok(response)","highlight_start":5,"highlight_end":7}],"label":"cannot infer type of the type parameter `E` declared on the enum `Result`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"cannot satisfy `_: IntoResponse`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the following types implement trait `IntoResponse`:\n  &'static [u8; N]\n  &'static [u8]\n  &'static str\n  ()\n  (R,)\n  (T1, R)\n  (T1, T2, R)\n  (T1, T2, T3, R)\nand 122 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the full name for the type has been written to 'D:\\OneDrive\\Code\\Hihivrsite\\liveshow\\rust_backend\\target\\debug\\deps\\liveshow_backend-f2f05e831be9f182.long-type-1224444979007292525.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider specifying the generic arguments","code":null,"level":"help","spans":[{"file_name":"src\\middleware.rs","byte_start":968,"byte_end":968,"line_start":42,"line_end":42,"column_start":7,"column_end":7,"is_primary":true,"text":[{"text":"    Ok(response)","highlight_start":7,"highlight_end":7}],"label":null,"suggested_replacement":"::<axum::http::Response<axum::body::Body>, E>","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0283]\u001b[0m\u001b[1m\u001b[97m: type annotations needed\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\middleware.rs:42:5\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m42\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     Ok(response)\n   \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mcannot infer type of the type parameter `E` declared on the enum `Result`\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n   \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: cannot satisfy `_: IntoResponse`\n   \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mhelp\u001b[0m: the following types implement trait `IntoResponse`:\n             &'static [u8; N]\n             &'static [u8]\n             &'static str\n             ()\n             (R,)\n             (T1, R)\n             (T1, T2, R)\n             (T1, T2, T3, R)\n           and 122 others\n   \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: the full name for the type has been written to 'D:\\OneDrive\\Code\\Hihivrsite\\liveshow\\rust_backend\\target\\debug\\deps\\liveshow_backend-f2f05e831be9f182.long-type-1224444979007292525.txt'\n   \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\u001b[1m\u001b[96mhelp\u001b[0m: consider specifying the generic arguments\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m42\u001b[0m \u001b[1m\u001b[96m| \u001b[0m    Ok\u001b[92m::<axum::http::Response<axum::body::Body>, E>\u001b[0m(response)\n   \u001b[1m\u001b[96m|\u001b[0m       \u001b[92m+++++++++++++++++++++++++++++++++++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"variable does not need to be mutable","code":{"code":"unused_mut","explanation":null},"level":"warning","spans":[{"file_name":"src\\middleware.rs","byte_start":1070,"byte_end":1077,"line_start":47,"line_end":47,"column_start":5,"column_end":12,"is_primary":true,"text":[{"text":"    mut req: Request<axum::body::Body>,","highlight_start":5,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_mut)]` (part of `#[warn(unused)]`) on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"remove this `mut`","code":null,"level":"help","spans":[{"file_name":"src\\middleware.rs","byte_start":1070,"byte_end":1074,"line_start":47,"line_end":47,"column_start":5,"column_end":9,"is_primary":true,"text":[{"text":"    mut req: Request<axum::body::Body>,","highlight_start":5,"highlight_end":9}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: variable does not need to be mutable\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\middleware.rs:47:5\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m47\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     mut req: Request<axum::body::Body>,\n   \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[96m----\u001b[0m\u001b[1m\u001b[93m^^^\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[96m|\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[96mhelp: remove this `mut`\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n   \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: `#[warn(unused_mut)]` (part of `#[warn(unused)]`) on by default\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0283","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0283\nlet x = \"hello\".chars().rev().collect();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nA common example is the `collect` method on `Iterator`. It has a generic type\nparameter with a `FromIterator` bound, which for a `char` iterator is\nimplemented by `Vec` and `String` among others. Consider the following snippet\nthat reverses the characters of a string:\n\nIn the first code example, the compiler cannot infer what the type of `x` should\nbe: `Vec<char>` and `String` are both suitable candidates. To specify which type\nto use, you can use a type annotation on `x`:\n\n```\nlet x: Vec<char> = \"hello\".chars().rev().collect();\n```\n\nIt is not necessary to annotate the full type. Once the ambiguity is resolved,\nthe compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nWe can see a self-contained example below:\n\n```compile_fail,E0283\nstruct Foo;\n\nimpl Into<u32> for Foo {\n    fn into(self) -> u32 { 1 }\n}\n\nlet foo = Foo;\nlet bar: u32 = foo.into() * 1u32;\n```\n\nThis error can be solved by adding type annotations that provide the missing\ninformation to the compiler. In this case, the solution is to specify the\ntrait's type parameter:\n\n```\nstruct Foo;\n\nimpl Into<u32> for Foo {\n    fn into(self) -> u32 { 1 }\n}\n\nlet foo = Foo;\nlet bar: u32 = Into::<u32>::into(foo) * 1u32;\n```\n"},"level":"error","spans":[{"file_name":"src\\middleware.rs","byte_start":3510,"byte_end":3512,"line_start":122,"line_end":122,"column_start":5,"column_end":7,"is_primary":true,"text":[{"text":"    Ok(response)","highlight_start":5,"highlight_end":7}],"label":"cannot infer type of the type parameter `E` declared on the enum `Result`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"cannot satisfy `_: IntoResponse`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the following types implement trait `IntoResponse`:\n  &'static [u8; N]\n  &'static [u8]\n  &'static str\n  ()\n  (R,)\n  (T1, R)\n  (T1, T2, R)\n  (T1, T2, T3, R)\nand 122 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the full name for the type has been written to 'D:\\OneDrive\\Code\\Hihivrsite\\liveshow\\rust_backend\\target\\debug\\deps\\liveshow_backend-f2f05e831be9f182.long-type-1224444979007292525.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider specifying the generic arguments","code":null,"level":"help","spans":[{"file_name":"src\\middleware.rs","byte_start":3512,"byte_end":3512,"line_start":122,"line_end":122,"column_start":7,"column_end":7,"is_primary":true,"text":[{"text":"    Ok(response)","highlight_start":7,"highlight_end":7}],"label":null,"suggested_replacement":"::<axum::http::Response<axum::body::Body>, E>","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0283]\u001b[0m\u001b[1m\u001b[97m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0msrc\\middleware.rs:122:5\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m122\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     Ok(response)\n    \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mcannot infer type of the type parameter `E` declared on the enum `Result`\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: cannot satisfy `_: IntoResponse`\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mhelp\u001b[0m: the following types implement trait `IntoResponse`:\n              &'static [u8; N]\n              &'static [u8]\n              &'static str\n              ()\n              (R,)\n              (T1, R)\n              (T1, T2, R)\n              (T1, T2, T3, R)\n            and 122 others\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: the full name for the type has been written to 'D:\\OneDrive\\Code\\Hihivrsite\\liveshow\\rust_backend\\target\\debug\\deps\\liveshow_backend-f2f05e831be9f182.long-type-1224444979007292525.txt'\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\u001b[1m\u001b[96mhelp\u001b[0m: consider specifying the generic arguments\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m122\u001b[0m \u001b[1m\u001b[96m| \u001b[0m    Ok\u001b[92m::<axum::http::Response<axum::body::Body>, E>\u001b[0m(response)\n    \u001b[1m\u001b[96m|\u001b[0m       \u001b[92m+++++++++++++++++++++++++++++++++++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"`?` couldn't convert the error to `(axum::http::StatusCode, std::string::String)`","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src\\main.rs","byte_start":9910,"byte_end":10063,"line_start":344,"line_end":347,"column_start":21,"column_end":88,"is_primary":false,"text":[{"text":"    let json_text = timeout(","highlight_start":21,"highlight_end":29},{"text":"        Duration::from_secs(10),","highlight_start":1,"highlight_end":33},{"text":"        response.text()","highlight_start":1,"highlight_end":24},{"text":"    ).await.map_err(|_| (StatusCode::REQUEST_TIMEOUT, \"Response timeout\".to_string()))??;","highlight_start":1,"highlight_end":88}],"label":"this can't be annotated with `?` because it has type `Result<_, reqwest::Error>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":10063,"byte_end":10064,"line_start":347,"line_end":347,"column_start":88,"column_end":89,"is_primary":true,"text":[{"text":"    ).await.map_err(|_| (StatusCode::REQUEST_TIMEOUT, \"Response timeout\".to_string()))??;","highlight_start":88,"highlight_end":89}],"label":"the trait `From<reqwest::Error>` is not implemented for `(axum::http::StatusCode, std::string::String)`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src\\main.rs","byte_start":10063,"byte_end":10064,"line_start":347,"line_end":347,"column_start":88,"column_end":89,"is_primary":false,"text":[{"text":"    ).await.map_err(|_| (StatusCode::REQUEST_TIMEOUT, \"Response timeout\".to_string()))??;","highlight_start":88,"highlight_end":89}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"desugaring of operator `?`","def_site_span":{"file_name":"src\\main.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `From<T>`:\n  `(T, T)` implements `From<[T; 2]>`\n  `(T, T, T)` implements `From<[T; 3]>`\n  `(T, T, T, T)` implements `From<[T; 4]>`\n  `(T, T, T, T, T)` implements `From<[T; 5]>`\n  `(T, T, T, T, T, T)` implements `From<[T; 6]>`\n  `(T, T, T, T, T, T, T)` implements `From<[T; 7]>`\n  `(T, T, T, T, T, T, T, T)` implements `From<[T; 8]>`\n  `(T, T, T, T, T, T, T, T, T)` implements `From<[T; 9]>`\nand 5 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the full name for the type has been written to 'D:\\OneDrive\\Code\\Hihivrsite\\liveshow\\rust_backend\\target\\debug\\deps\\liveshow_backend-f2f05e831be9f182.long-type-4401022554599410018.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m\u001b[97m: `?` couldn't convert the error to `(axum::http::StatusCode, std::string::String)`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0msrc\\main.rs:347:88\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m344\u001b[0m \u001b[1m\u001b[96m|\u001b[0m       let json_text = timeout(\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[96m _____________________-\u001b[0m\n\u001b[1m\u001b[96m345\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         Duration::from_secs(10),\n\u001b[1m\u001b[96m346\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         response.text()\n\u001b[1m\u001b[96m347\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     ).await.map_err(|_| (StatusCode::REQUEST_TIMEOUT, \"Response timeout\".to_string()))??;\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                                                                                       \u001b[1m\u001b[96m-\u001b[0m\u001b[1m\u001b[91m^\u001b[0m \u001b[1m\u001b[91mthe trait `From<reqwest::Error>` is not implemented for `(axum::http::StatusCode, std::string::String)`\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[96m|_______________________________________________________________________________________|\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m                                                                                         \u001b[1m\u001b[96mthis can't be annotated with `?` because it has type `Result<_, reqwest::Error>`\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mhelp\u001b[0m: the following other types implement trait `From<T>`:\n              `(T, T)` implements `From<[T; 2]>`\n              `(T, T, T)` implements `From<[T; 3]>`\n              `(T, T, T, T)` implements `From<[T; 4]>`\n              `(T, T, T, T, T)` implements `From<[T; 5]>`\n              `(T, T, T, T, T, T)` implements `From<[T; 6]>`\n              `(T, T, T, T, T, T, T)` implements `From<[T; 7]>`\n              `(T, T, T, T, T, T, T, T)` implements `From<[T; 8]>`\n              `(T, T, T, T, T, T, T, T, T)` implements `From<[T; 9]>`\n            and 5 others\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: the full name for the type has been written to 'D:\\OneDrive\\Code\\Hihivrsite\\liveshow\\rust_backend\\target\\debug\\deps\\liveshow_backend-f2f05e831be9f182.long-type-4401022554599410018.txt'\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `AllowOrigin: FromStr` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src\\middleware.rs","byte_start":3750,"byte_end":3755,"line_start":132,"line_end":132,"column_start":37,"column_end":42,"is_primary":true,"text":[{"text":"            \"http://localhost:2992\".parse::<AllowOrigin>().unwrap(),","highlight_start":37,"highlight_end":42}],"label":"the trait `FromStr` is not implemented for `AllowOrigin`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `FromStr`:\n  Authority\n  ByteString\n  CString\n  DateTime<FixedOffset>\n  DateTime<Local>\n  DateTime<Utc>\n  Directive\n  EnvFilter\nand 91 others","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m\u001b[97m: the trait bound `AllowOrigin: FromStr` is not satisfied\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0msrc\\middleware.rs:132:37\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m132\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             \"http://localhost:2992\".parse::<AllowOrigin>().unwrap(),\n    \u001b[1m\u001b[96m|\u001b[0m                                     \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `FromStr` is not implemented for `AllowOrigin`\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mhelp\u001b[0m: the following other types implement trait `FromStr`:\n              Authority\n              ByteString\n              CString\n              DateTime<FixedOffset>\n              DateTime<Local>\n              DateTime<Utc>\n              Directive\n              EnvFilter\n            and 91 others\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `AllowOrigin: FromStr` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src\\middleware.rs","byte_start":3819,"byte_end":3824,"line_start":133,"line_end":133,"column_start":37,"column_end":42,"is_primary":true,"text":[{"text":"            \"http://127.0.0.1:2992\".parse::<AllowOrigin>().unwrap(),","highlight_start":37,"highlight_end":42}],"label":"the trait `FromStr` is not implemented for `AllowOrigin`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `FromStr`:\n  Authority\n  ByteString\n  CString\n  DateTime<FixedOffset>\n  DateTime<Local>\n  DateTime<Utc>\n  Directive\n  EnvFilter\nand 91 others","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m\u001b[97m: the trait bound `AllowOrigin: FromStr` is not satisfied\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0msrc\\middleware.rs:133:37\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m133\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             \"http://127.0.0.1:2992\".parse::<AllowOrigin>().unwrap(),\n    \u001b[1m\u001b[96m|\u001b[0m                                     \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `FromStr` is not implemented for `AllowOrigin`\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mhelp\u001b[0m: the following other types implement trait `FromStr`:\n              Authority\n              ByteString\n              CString\n              DateTime<FixedOffset>\n              DateTime<Local>\n              DateTime<Utc>\n              Directive\n              EnvFilter\n            and 91 others\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `AllowOrigin: FromStr` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src\\middleware.rs","byte_start":3889,"byte_end":3894,"line_start":134,"line_end":134,"column_start":38,"column_end":43,"is_primary":true,"text":[{"text":"            \"https://localhost:2992\".parse::<AllowOrigin>().unwrap(),","highlight_start":38,"highlight_end":43}],"label":"the trait `FromStr` is not implemented for `AllowOrigin`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `FromStr`:\n  Authority\n  ByteString\n  CString\n  DateTime<FixedOffset>\n  DateTime<Local>\n  DateTime<Utc>\n  Directive\n  EnvFilter\nand 91 others","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m\u001b[97m: the trait bound `AllowOrigin: FromStr` is not satisfied\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0msrc\\middleware.rs:134:38\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m134\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             \"https://localhost:2992\".parse::<AllowOrigin>().unwrap(),\n    \u001b[1m\u001b[96m|\u001b[0m                                      \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `FromStr` is not implemented for `AllowOrigin`\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mhelp\u001b[0m: the following other types implement trait `FromStr`:\n              Authority\n              ByteString\n              CString\n              DateTime<FixedOffset>\n              DateTime<Local>\n              DateTime<Utc>\n              Directive\n              EnvFilter\n            and 91 others\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `AllowOrigin: FromStr` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src\\middleware.rs","byte_start":3959,"byte_end":3964,"line_start":135,"line_end":135,"column_start":38,"column_end":43,"is_primary":true,"text":[{"text":"            \"https://127.0.0.1:2992\".parse::<AllowOrigin>().unwrap(),","highlight_start":38,"highlight_end":43}],"label":"the trait `FromStr` is not implemented for `AllowOrigin`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `FromStr`:\n  Authority\n  ByteString\n  CString\n  DateTime<FixedOffset>\n  DateTime<Local>\n  DateTime<Utc>\n  Directive\n  EnvFilter\nand 91 others","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m\u001b[97m: the trait bound `AllowOrigin: FromStr` is not satisfied\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0msrc\\middleware.rs:135:38\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m135\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             \"https://127.0.0.1:2992\".parse::<AllowOrigin>().unwrap(),\n    \u001b[1m\u001b[96m|\u001b[0m                                      \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `FromStr` is not implemented for `AllowOrigin`\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mhelp\u001b[0m: the following other types implement trait `FromStr`:\n              Authority\n              ByteString\n              CString\n              DateTime<FixedOffset>\n              DateTime<Local>\n              DateTime<Utc>\n              Directive\n              EnvFilter\n            and 91 others\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `AllowOrigin: From<[AllowOrigin; 4]>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src\\middleware.rs","byte_start":3712,"byte_end":4001,"line_start":131,"line_end":136,"column_start":23,"column_end":10,"is_primary":true,"text":[{"text":"        .allow_origin([","highlight_start":23,"highlight_end":24},{"text":"            \"http://localhost:2992\".parse::<AllowOrigin>().unwrap(),","highlight_start":1,"highlight_end":69},{"text":"            \"http://127.0.0.1:2992\".parse::<AllowOrigin>().unwrap(),","highlight_start":1,"highlight_end":69},{"text":"            \"https://localhost:2992\".parse::<AllowOrigin>().unwrap(),","highlight_start":1,"highlight_end":70},{"text":"            \"https://127.0.0.1:2992\".parse::<AllowOrigin>().unwrap(),","highlight_start":1,"highlight_end":70},{"text":"        ])","highlight_start":1,"highlight_end":10}],"label":"the trait `From<[AllowOrigin; 4]>` is not implemented for `AllowOrigin`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\middleware.rs","byte_start":3699,"byte_end":3711,"line_start":131,"line_end":131,"column_start":10,"column_end":22,"is_primary":false,"text":[{"text":"        .allow_origin([","highlight_start":10,"highlight_end":22}],"label":"required by a bound introduced by this call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `From<T>`:\n  `AllowOrigin` implements `From<Vec<axum::http::HeaderValue>>`\n  `AllowOrigin` implements `From<[axum::http::HeaderValue; N]>`\n  `AllowOrigin` implements `From<axum::http::HeaderValue>`\n  `AllowOrigin` implements `From<tower_http::cors::Any>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `[AllowOrigin; 4]` to implement `Into<AllowOrigin>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `CorsLayer::allow_origin`","code":null,"level":"note","spans":[{"file_name":"C:\\Users\\PMA2138\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tower-http-0.5.2\\src\\cors\\mod.rs","byte_start":10249,"byte_end":10261,"line_start":333,"line_end":333,"column_start":12,"column_end":24,"is_primary":false,"text":[{"text":"    pub fn allow_origin<T>(mut self, origin: T) -> Self","highlight_start":12,"highlight_end":24}],"label":"required by a bound in this associated function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"C:\\Users\\PMA2138\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tower-http-0.5.2\\src\\cors\\mod.rs","byte_start":10315,"byte_end":10332,"line_start":335,"line_end":335,"column_start":12,"column_end":29,"is_primary":true,"text":[{"text":"        T: Into<AllowOrigin>,","highlight_start":12,"highlight_end":29}],"label":"required by this bound in `CorsLayer::allow_origin`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m\u001b[97m: the trait bound `AllowOrigin: From<[AllowOrigin; 4]>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0msrc\\middleware.rs:131:23\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m131\u001b[0m \u001b[1m\u001b[96m|\u001b[0m           .allow_origin([\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m __________\u001b[0m\u001b[1m\u001b[96m------------\u001b[0m\u001b[1m\u001b[91m_^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m          \u001b[1m\u001b[96m|\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m          \u001b[1m\u001b[96mrequired by a bound introduced by this call\u001b[0m\n\u001b[1m\u001b[96m132\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m             \"http://localhost:2992\".parse::<AllowOrigin>().unwrap(),\n\u001b[1m\u001b[96m133\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m             \"http://127.0.0.1:2992\".parse::<AllowOrigin>().unwrap(),\n\u001b[1m\u001b[96m134\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m             \"https://localhost:2992\".parse::<AllowOrigin>().unwrap(),\n\u001b[1m\u001b[96m135\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m             \"https://127.0.0.1:2992\".parse::<AllowOrigin>().unwrap(),\n\u001b[1m\u001b[96m136\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         ])\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|_________^\u001b[0m \u001b[1m\u001b[91mthe trait `From<[AllowOrigin; 4]>` is not implemented for `AllowOrigin`\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mhelp\u001b[0m: the following other types implement trait `From<T>`:\n              `AllowOrigin` implements `From<Vec<axum::http::HeaderValue>>`\n              `AllowOrigin` implements `From<[axum::http::HeaderValue; N]>`\n              `AllowOrigin` implements `From<axum::http::HeaderValue>`\n              `AllowOrigin` implements `From<tower_http::cors::Any>`\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: required for `[AllowOrigin; 4]` to implement `Into<AllowOrigin>`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `CorsLayer::allow_origin`\n   \u001b[1m\u001b[96m--> \u001b[0mC:\\Users\\PMA2138\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tower-http-0.5.2\\src\\cors\\mod.rs:335:12\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m333\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     pub fn allow_origin<T>(mut self, origin: T) -> Self\n    \u001b[1m\u001b[96m|\u001b[0m            \u001b[1m\u001b[96m------------\u001b[0m \u001b[1m\u001b[96mrequired by a bound in this associated function\u001b[0m\n\u001b[1m\u001b[96m334\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     where\n\u001b[1m\u001b[96m335\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         T: Into<AllowOrigin>,\n    \u001b[1m\u001b[96m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `CorsLayer::allow_origin`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"aborting due to 8 previous errors; 2 warnings emitted","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: aborting due to 8 previous errors; 2 warnings emitted\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"Some errors have detailed explanations: E0277, E0283.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1m\u001b[97mSome errors have detailed explanations: E0277, E0283.\u001b[0m\n"}
{"$message_type":"diagnostic","message":"For more information about an error, try `rustc --explain E0277`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1m\u001b[97mFor more information about an error, try `rustc --explain E0277`.\u001b[0m\n"}
